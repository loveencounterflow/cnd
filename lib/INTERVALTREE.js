// Generated by CoffeeScript 1.9.1
(function() {
  var CND, get_m, get_m_sym, is_clean_sym, is_decorated_sym, m_sym, parent_sym;

  CND = require('./main');

  is_decorated_sym = Symbol('is_decorated');

  is_clean_sym = Symbol('is_clean');

  parent_sym = Symbol('parent');

  get_m_sym = Symbol('get_m');

  m_sym = Symbol('m');

  this.new_tree = function() {
    return {
      '~isa': 'CND/interval-tree',
      '%self': (require('functional-red-black-tree'))()
    };
  };

  this.add_interval = function(me, interval) {
    me['%self'] = me['%self'].insert(interval[0], interval);
    me['%self']['root'][is_clean_sym] = false;
    return me;
  };

  get_m = function() {
    var R, left_m, ref, ref1, ref2, ref3, right_m;
    if (typeof R !== "undefined" && R !== null) {
      return (R = this[m_sym]);
    }
    left_m = (ref = (ref1 = this['left']) != null ? ref1[get_m_sym]() : void 0) != null ? ref : -Infinity;
    right_m = (ref2 = (ref3 = this['right']) != null ? ref3[get_m_sym]() : void 0) != null ? ref2 : -Infinity;
    return this[m_sym] = Math.max(left_m, right_m, this['value'][1]);
  };

  this._get_m = function(node) {
    return node[get_m_sym]();
  };

  this._get_parent = function(node) {
    return node[parent_sym];
  };

  this._decorate = function(node) {

    /* TAINT single signalling symbol is enough */
    var left_node, right_node;
    if (node[is_decorated_sym] && node[is_clean_sym]) {
      return null;
    }
    console.log('decorate');
    node[get_m_sym] = get_m;
    node[m_sym] = null;
    if ((left_node = node['left']) != null) {
      left_node[parent_sym] = node;
      this._decorate(left_node);
    }
    if ((right_node = node['right']) != null) {
      right_node[parent_sym] = node;
      this._decorate(right_node);
    }
    node[is_clean_sym] = true;
    node[is_decorated_sym] = true;
    return null;
  };

  this.find = function(me, probe) {
    var root;
    root = me['%self']['root'];
    this._decorate(root);
    if (!CND.isa_list(probe)) {
      probe = [probe, probe];
    }
    return this._find(root, probe, []);
  };

  this._find = function(node, probe, R) {
    var left_node, node_hi, node_lo, probe_hi, probe_lo, ref, right_node;
    probe_lo = probe[0], probe_hi = probe[1];
    ref = node['value'], node_lo = ref[0], node_hi = ref[1];
    if (!(probe_lo > node_hi || probe_hi < node_lo)) {
      R.push(node['value']);
    }
    left_node = node['left'];
    right_node = node['right'];
    if ((left_node == null) && (right_node == null)) {
      return R;
    }
    if (node['left'] == null) {
      return this._find(right_node, probe, R);
    }
    if ((right_node != null) && left_node[get_m_sym]() < probe_lo) {
      return this._find(right_node, probe, R);
    }
    if (left_node != null) {
      return this._find(left_node, probe, R);
    }
    return R;
  };

  this._demo = function() {
    var ITREE, badge, help, i, interval, intervals, len, search, show, tree, urge;
    badge = 'CND/INTERVALTREE/demo';
    help = CND.get_logger('help', badge);
    urge = CND.get_logger('urge', badge);
    ITREE = this;
    show = function(node) {
      var left_node, right_node, this_key, this_m, this_value;
      this_key = node['key'];
      this_value = node['value'];
      this_m = node[get_m_sym]();
      help(this_key, this_value, this_m);
      if ((left_node = node['left']) != null) {
        show(left_node);
      }
      if ((right_node = node['right']) != null) {
        show(right_node);
      }
      return null;
    };
    search = function() {
      var i, n, node, results;
      results = [];
      for (n = i = 0; i <= 15; n = ++i) {
        help(n);
        results.push((function() {
          var j, len, ref, results1;
          ref = ITREE.find(tree, n);
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            node = ref[j];
            results1.push(urge('  ', node['key'], node['value']));
          }
          return results1;
        })());
      }
      return results;
    };
    tree = ITREE.new_tree();
    intervals = [[3, 7, 'A'], [5, 7, 'B'], [8, 12, 'C1'], [8, 12, 'C2'], [2, 14, 'D'], [4, 4, 'E'], [10, 13, 'F'], [8, 22, 'G'], [1, 3, 'H']];
    for (i = 0, len = intervals.length; i < len; i++) {
      interval = intervals[i];
      ITREE.add_interval(tree, interval);
    }
    ITREE._decorate(tree['%self']['root']);
    show(tree['%self']['root']);
    search();
    ITREE.add_interval(tree, [10, 13, 'FF']);
    search();
    return null;
  };

  if (module.parent == null) {
    CND.dir(this);
    this._demo();
  }

}).call(this);
