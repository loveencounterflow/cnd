// Generated by CoffeeScript 1.9.1

/* Adapted from https://github.com/eknkc/tsort */

(function() {
  var CND,
    slice = [].slice;

  CND = require('./main');

  this.new_graph = function(settings) {
    var R, prefixes, ref, ref1, strict;
    if (settings == null) {
      settings = {};
    }
    strict = (ref = settings['strict']) != null ? ref : true;
    prefixes = (ref1 = settings['prefixes']) != null ? ref1 : null;
    R = {
      '~isa': 'CND/tsort-graph',
      'ps-by-cs': {},
      'strict': strict,
      'prefixes': prefixes,
      '%nodes': null
    };
    return R;
  };

  this.link_down = function(me, precedence, consequence) {

    /* TAINT check for trivial errors such as precedence == consequence */
    var base, base1;
    if ((base = me['ps-by-cs'])[precedence] == null) {
      base[precedence] = [];
    }
    ((base1 = me['ps-by-cs'])[consequence] != null ? base1[consequence] : base1[consequence] = []).push(precedence);
    return this._sort(me);
  };

  this.register = function() {
    var base, i, len, me, name, names;
    me = arguments[0], names = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    for (i = 0, len = names.length; i < len; i++) {
      name = names[i];
      if ((base = me['ps-by-cs'])[name] == null) {
        base[name] = [];
      }
    }
    return this._sort(me);
  };

  this.link_up = function(me, consequence, precedence) {
    return this.link_down(me, precedence, consequence);
  };

  this.link = function(me, f, r, g) {
    var prefixes;
    if ((prefixes = me['prefixes']) != null) {
      f = "" + prefixes[0] + f;
      g = "" + prefixes[1] + g;
    }
    switch (r) {
      case '>':
        return this.link_down(me, f, g);
      case '<':
        return this.link_down(me, g, f);
      case '-':
        return this.register(me, f, g);
      default:
        throw new Error("expected one of '<', '>', '-', got " + (CND.rpr(r)));
    }
    return null;
  };

  this._visit = function(me, results, marks, name) {
    var i, len, ref, sub_name;
    if (marks[name] === 'temp') {
      throw new Error("detected cycle involving node " + (CND.rpr(name)));
    }
    if (marks[name] != null) {
      return null;
    }
    marks[name] = 'temp';
    ref = me['ps-by-cs'][name];
    for (i = 0, len = ref.length; i < len; i++) {
      sub_name = ref[i];
      this._visit(me, results, marks, sub_name);
    }
    marks[name] = 'ok';
    results.push(name);
    return null;
  };

  this._sort = function(me) {
    me['%nodes'] = null;
    if (me['strict']) {
      return this.sort(me);
    } else {
      return null;
    }
  };

  this.get_precedences = function(me) {
    var R, delta, i, len, name, name_idx, nodes, ref;
    nodes = (ref = me['%nodes']) != null ? ref : this.sort(me);
    delta = nodes.length - 1;
    R = {};
    for (name_idx = i = 0, len = nodes.length; i < len; name_idx = ++i) {
      name = nodes[name_idx];
      R[name] = delta - name_idx;
    }
    return R;
  };

  this.precedence_of = function(me, name) {
    var R, nodes, ref;
    nodes = (ref = me['%nodes']) != null ? ref : this.sort(me);
    if (!((R = nodes.indexOf(name)) >= 0)) {
      throw new Error("unknown node " + (rpr(name)));
    }
    return nodes.length - R - 1;
  };

  this.sort = function(me) {

    /* As given in http://en.wikipedia.org/wiki/Topological_sorting */
    var R, i, len, marks, precedence, precedences;
    precedences = Object.keys(me['ps-by-cs']);
    R = [];
    marks = {};
    for (i = 0, len = precedences.length; i < len; i++) {
      precedence = precedences[i];
      if (marks[precedence] == null) {
        this._visit(me, R, marks, precedence);
      }
    }
    me['%nodes'] = R;
    return R;
  };

}).call(this);
