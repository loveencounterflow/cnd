// Generated by CoffeeScript 1.9.1

/* Adapted from https://github.com/eknkc/tsort */

(function() {
  var CND;

  CND = require('./main');

  this.new_graph = function(settings) {
    var R, prefixes, ref, ref1, strict;
    if (settings == null) {
      settings = {};
    }
    strict = (ref = settings['strict']) != null ? ref : true;
    prefixes = (ref1 = settings['prefixes']) != null ? ref1 : null;
    R = {
      '~isa': 'CND/tsort-graph',
      'ps-by-cs': {},
      'strict': strict,
      'prefixes': prefixes
    };
    return R;
  };

  this.link_down = function(me, precedence, consequence) {

    /* TAINT check for trivial errors such as precedence == consequence */
    var base, base1;
    if ((base = me['ps-by-cs'])[precedence] == null) {
      base[precedence] = [];
    }
    ((base1 = me['ps-by-cs'])[consequence] != null ? base1[consequence] : base1[consequence] = []).push(precedence);
    return this._sort(me);
  };

  this.link_up = function(me, consequence, precedence) {
    return this.link_down(me, precedence, consequence);
  };

  this.link = function(me, f, r, g) {
    var prefixes;
    if ((prefixes = me['prefixes']) != null) {
      f = "" + prefixes[0] + f;
      g = "" + prefixes[1] + g;
    }
    switch (r) {
      case '>':
        this.link_down(me, f, g);
        break;
      case '<':
        this.link_down(me, g, f);
        break;
      case '-':
        return me;
      default:
        throw new Error("expected one of '<', '>', '-', got " + (CND.rpr(r)));
    }
    return this._sort(me);
  };

  this._visit = function(me, results, marks, name) {
    var i, len, ref, sub_name;
    if (marks[name] === 'temp') {
      throw new Error("detected cycle involving node " + (CND.rpr(name)));
    }
    if (marks[name] != null) {
      return null;
    }
    marks[name] = 'temp';
    ref = me['ps-by-cs'][name];
    for (i = 0, len = ref.length; i < len; i++) {
      sub_name = ref[i];
      this._visit(me, results, marks, sub_name);
    }
    marks[name] = 'ok';
    results.push(name);
    return null;
  };

  this._sort = function(me) {
    if (me['strict']) {
      return this.sort(me);
    } else {
      return null;
    }
  };

  this.sort = function(me) {

    /* As given in http://en.wikipedia.org/wiki/Topological_sorting */
    var R, i, len, marks, precedence, precedences;
    precedences = Object.keys(me['ps-by-cs']);
    R = [];
    marks = {};
    for (i = 0, len = precedences.length; i < len; i++) {
      precedence = precedences[i];
      if (marks[precedence] == null) {
        this._visit(me, R, marks, precedence);
      }
    }
    return R;
  };

}).call(this);
