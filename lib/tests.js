// Generated by CoffeeScript 1.10.0
(function() {
  var CND, TRM, alert, badge, debug, echo, help, include, info, log, njs_path, praise, rpr, test, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  njs_path = require('path');

  TRM = require('./TRM');

  rpr = TRM.rpr.bind(TRM);

  badge = 'BITSNPIECES/test';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  urge = TRM.get_logger('urge', badge);

  praise = TRM.get_logger('praise', badge);

  echo = TRM.echo.bind(TRM);

  CND = require('./main');

  test = require('guy-test');

  this['test type_of'] = function(T) {
    T.eq(CND.type_of(new WeakMap()), 'weakmap');
    T.eq(CND.type_of(new Map()), 'map');
    T.eq(CND.type_of(new Set()), 'set');
    T.eq(CND.type_of(new Date()), 'date');
    T.eq(CND.type_of(new Error()), 'error');
    T.eq(CND.type_of([]), 'list');
    T.eq(CND.type_of(true), 'boolean');
    T.eq(CND.type_of(false), 'boolean');
    T.eq(CND.type_of((function() {})), 'function');
    T.eq(CND.type_of((function*() {
      return (yield 123);
    })()), 'generator');
    T.eq(CND.type_of(null), 'null');
    T.eq(CND.type_of('helo'), 'text');
    T.eq(CND.type_of(void 0), 'undefined');
    T.eq(CND.type_of(arguments), 'arguments');
    T.eq(CND.type_of(global), 'global');
    T.eq(CND.type_of(/^xxx$/g), 'regex');
    T.eq(CND.type_of({}), 'pod');
    T.eq(CND.type_of(NaN), 'nan');
    T.eq(CND.type_of(1 / 0), 'infinity');
    T.eq(CND.type_of(-1 / 0), 'infinity');
    T.eq(CND.type_of(12345), 'number');
    T.eq(CND.type_of(new Buffer('helo')), 'buffer');
    T.eq(CND.type_of(new ArrayBuffer(42)), 'arraybuffer');
    return null;
  };

  this['test size_of'] = function(T) {
    T.eq(CND.size_of([1, 2, 3, 4]), 4);
    T.eq(CND.size_of(new Buffer([1, 2, 3, 4])), 4);
    T.eq(CND.size_of('𣁬𡉜𠑹𠅁'), 2 * (Array.from('𣁬𡉜𠑹𠅁')).length);
    T.eq(CND.size_of('𣁬𡉜𠑹𠅁', {
      count: 'codepoints'
    }), (Array.from('𣁬𡉜𠑹𠅁')).length);
    T.eq(CND.size_of('𣁬𡉜𠑹𠅁', {
      count: 'codeunits'
    }), 2 * (Array.from('𣁬𡉜𠑹𠅁')).length);
    T.eq(CND.size_of('𣁬𡉜𠑹𠅁', {
      count: 'bytes'
    }), (new Buffer('𣁬𡉜𠑹𠅁', 'utf-8')).length);
    T.eq(CND.size_of('abcdefghijklmnopqrstuvwxyz'), 26);
    T.eq(CND.size_of('abcdefghijklmnopqrstuvwxyz', {
      count: 'codepoints'
    }), 26);
    T.eq(CND.size_of('abcdefghijklmnopqrstuvwxyz', {
      count: 'codeunits'
    }), 26);
    T.eq(CND.size_of('abcdefghijklmnopqrstuvwxyz', {
      count: 'bytes'
    }), 26);
    T.eq(CND.size_of('ä'), 1);
    T.eq(CND.size_of('ä', {
      count: 'codepoints'
    }), 1);
    T.eq(CND.size_of('ä', {
      count: 'codeunits'
    }), 1);
    T.eq(CND.size_of('ä', {
      count: 'bytes'
    }), 2);
    T.eq(CND.size_of(new Map([['foo', 42], ['bar', 108]])), 2);
    T.eq(CND.size_of(new Set(['foo', 42, 'bar', 108])), 4);
    T.eq(CND.size_of({
      'foo': 42,
      'bar': 108,
      'baz': 3
    }), 3);
    return T.eq(CND.size_of({
      '~isa': 'XYZ/yadda',
      'foo': 42,
      'bar': 108,
      'baz': 3
    }), 4);
  };

  this['XJSON'] = function(T) {
    var d, e;
    CND.XJSON = require('./XJSON');
    e = new Set('xy');
    e.add(new Set('abc'));
    d = ['A', 'B', e];
    help(d);
    info(CND.XJSON.stringify(d));
    info(CND.XJSON.parse(CND.XJSON.stringify(d)));
    T.eq(CND.XJSON.stringify(d), "[\"A\",\"B\",{\"~isa\":\"set\",\"%self\":[\"x\",\"y\",{\"~isa\":\"set\",\"%self\":[\"a\",\"b\",\"c\"]}]}]");

    /* TAINT doing string comparison here to avoid implicit test that T.eq deals with sets correctly */
    return T.eq(rpr(CND.XJSON.parse(CND.XJSON.stringify(d))), "[ 'A', 'B', Set { 'x', 'y', Set { 'a', 'b', 'c' } } ]");
  };

  this['is_subset'] = function(T) {
    T.eq(false, CND.is_subset(Array.from('abcde'), Array.from('abcd')));
    T.eq(false, CND.is_subset(Array.from('abcx'), Array.from('abcd')));
    T.eq(false, CND.is_subset(Array.from('abcd'), []));
    T.eq(true, CND.is_subset(Array.from('abcd'), Array.from('abcd')));
    T.eq(true, CND.is_subset(Array.from('abc'), Array.from('abcd')));
    T.eq(true, CND.is_subset([], Array.from('abcd')));
    T.eq(true, CND.is_subset([], Array.from([])));
    T.eq(false, CND.is_subset(new Set('abcde'), new Set('abcd')));
    T.eq(false, CND.is_subset(new Set('abcx'), new Set('abcd')));
    T.eq(false, CND.is_subset(new Set('abcx'), new Set()));
    T.eq(true, CND.is_subset(new Set('abcd'), new Set('abcd')));
    T.eq(true, CND.is_subset(new Set('abc'), new Set('abcd')));
    T.eq(true, CND.is_subset(new Set(), new Set('abcd')));
    return T.eq(true, CND.is_subset(new Set(), new Set()));
  };

  this._main = function(handler) {
    return test(this, {
      'timeout': 2500
    });
  };

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  if (module.parent == null) {
    include = ['XJSON'];
    this._main();
  }

}).call(this);

//# sourceMappingURL=tests.js.map
